#!/usr/bin/env python3

import subprocess
import argparse
import shutil
import os
import re
from datetime import datetime

def create_backup(manifest_file):
    """
    Creates a backup of the manifest file by appending '.backup' to its name.
    If a backup already exists, it is removed first.
    Returns the backup file path.
    """
    backup_file = manifest_file + ".backup"
    if os.path.exists(backup_file):
        os.remove(backup_file)
        print(f"Deleted existing backup file: {backup_file}")
    shutil.copy2(manifest_file, backup_file)
    print(f"Created backup file: {backup_file}")
    return backup_file

def dasel_read(manifest_file, selector=""):
    """
    Helper function to run a dasel get command and return the output.
    If selector is empty, the "--selector" flag is omitted.
    """
    cmd = [
        "dasel",
        "--file", manifest_file,
        "--read", "yaml"
    ]
    if selector:
        cmd.extend(["--selector", selector])
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()

def dasel_count(manifest_file, key):
    """
    Helper function to run a dasel get command that uses the count() function on the given key.
    For example, if key is "whateverThing", this function will run:
    
      dasel --file <manifest_file> --read yaml --selector 'whateverThing.all().count()' --type yaml
      
    and return the output.
    """
    selector = f"{key}.all().count()"
    cmd = [
        "dasel",
        "--file", manifest_file,
        "--read", "yaml",
        "--selector", selector,
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()

def get_toplevel_keys(file_path):
    """
    Uses dasel_read on the provided file (with an empty selector)
    to extract the top-level keys from the YAML.
    For example, if the file contains:
      firstThing: null
      whateverThing: null
    then this function returns ["firstThing", "whateverThing"].
    """
    output = dasel_read(file_path, "")
    # Use regex to capture keys at the start of a line
    keys = re.findall(r'^(\S+):', output, re.MULTILINE)
    return keys

def get_list_count_for_keys(manifest_file, keys):
    """
    For each key in the provided list, use dasel_count to retrieve the count of list items
    from the manifest file. Returns a dict mapping each key to its list count (as an integer)
    or None if an error occurs.
    """
    counts = {}
    for key in keys:
        try:
            count_output = dasel_count(manifest_file, key)
            counts[key] = int(count_output)
        except Exception as e:
            print(f"Error retrieving count for key '{key}': {e}")
            counts[key] = None
    return counts


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="YAML update tool")
    parser.add_argument('subcommand', choices=['put'],
                        help="Subcommand: 'put' (currently the only supported action)")
    parser.add_argument('manifest_file',
                        help="Path to the target manifest YAML file (e.g. repo/manifest-01/manifest.yaml)")
    parser.add_argument('--replacements_dir',
                        help="Directory containing updates (not used in this minimal example)")
    args = parser.parse_args()

    if not args.manifest_file:
        print("Error: manifest_file must be provided")
        exit(1)

    if not args.replacements_dir:
        print("Error: --replacements_dir must be provided")
        exit(1)

    backup_file = create_backup(args.manifest_file)

    replacements_file = args.replacements_dir + '/listincrement.yaml'
    keys = get_toplevel_keys(replacements_file)
    counts = get_list_count_for_keys(args.manifest_file, keys)
    print("List counts for keys:", counts)