#!/usr/bin/env python3

import subprocess
import argparse
import shutil
import os
import re
from typing import Dict, List
from datetime import datetime

def create_backup(manifest_file):
    """
    Creates a backup of the manifest file by appending '.backup' to its name.
    If a backup already exists, it is removed first.
    Returns the backup file path.
    """
    backup_file = manifest_file + ".backup"
    if os.path.exists(backup_file):
        os.remove(backup_file)
        print(f"Deleted existing backup file: {backup_file}")
    shutil.copy2(manifest_file, backup_file)
    print(f"Created backup file: {backup_file}")
    return backup_file

def dasel_read(manifest_file, selector=""):
    """
    Helper function to run a dasel get command and return the output.
    If selector is empty, the "--selector" flag is omitted.
    """
    cmd = [
        "dasel",
        "--file", manifest_file,
        "--read", "yaml"
    ]
    if selector:
        cmd.extend(["--selector", selector])
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()

def get_toplevel_keys(file_path):
    """
    Uses dasel_read on the provided file (with an empty selector)
    to extract the top-level keys from the YAML.
    For example, if the file contains:
      firstThing: null
      whateverThing: null
    then this function returns ["firstThing", "whateverThing"].
    """
    output = dasel_read(file_path, "")
    # Use regex to capture keys at the start of a line
    keys = re.findall(r'^(\S+):', output, re.MULTILINE)
    return keys

def dasel_last_index_for_key(manifest_file, key):
    """
    Helper function to run a dasel get command that uses the count() function on the given key.
    For example, if key is "whateverThing", this function will run:
    
      dasel --file <manifest_file> --read yaml --selector 'whateverThing.all().count()' --type yaml
      
    and return the output.
    """
    selector = f"{key}.all().count()"
    cmd = [
        "dasel",
        "--file", manifest_file,
        "--read", "yaml",
        "--selector", selector,
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()

def get_last_list_index_for_key(manifest_file, keys):
    """
    For each key in the provided list, provide a dict showing the last index
    in the list under a given key.
    """
    counts = {}
    for key in keys:
        try:
            count_output = dasel_last_index_for_key(manifest_file, key)
            counts[key] = int(count_output) - 1
        except Exception as e:
            print(f"Error retrieving count for key '{key}': {e}")
            counts[key] = None
    return counts

def get_last_item_elements(manifest_file, key, last_index):
    """
    For a given key in the manifest file, constructs a selector for the last element in the list,
    reads its YAML with dasel_read, and returns the keys (if the element is a dictionary).
    
    For example, if key is "whateverThing" and last_index is 1,
    it runs:
      dasel --file <manifest_file> --read yaml --selector 'whateverThing.[1]' --type yaml
    and returns the list of keys in that mapping.
    """
    selector = f"{key}.[{last_index}]"
    output = dasel_read(manifest_file, selector)
    try:
        data = yaml.safe_load(output)
    except Exception as e:
        print(f"Error loading YAML for selector '{selector}': {e}")
        return []
    
    if isinstance(data, dict):
        return list(data.keys())
    else:
        print(f"Data for selector '{selector}' is not a mapping. Found type: {type(data)}")
        return []

def get_list_item_key_values(manifest_file: str, counts_dict: Dict[str, int]) -> Dict[str, List[Dict[str, str]]]:
    """
    For each key in counts_dict (which maps top-level keys to their last index),
    constructs a selector to get the last list item, uses dasel_read to retrieve
    its output (as a multi-line string), then splits that output into lines and
    parses each line into a dict with one key–value pair.
    
    Returns a dictionary mapping each key to a list of dictionaries (one per line).
    """
    result: Dict[str, List[Dict[str, str]]] = {}
    for key, last_index in counts_dict.items():
        selector: str = f"{key}.[{last_index}]"
        output: str = dasel_read(manifest_file, selector)
        line_dicts: List[Dict[str, str]] = []
        for line in output.splitlines():
            if line.strip():  # skip blank lines
                if ":" in line:
                    parts = line.split(":", 1)
                    k = parts[0].strip()
                    v = parts[1].strip()
                    # Remove surrounding quotes if present
                    if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
                        v = v[1:-1]
                    line_dicts.append({k: v})
        result[key] = line_dicts
    return result

def update_if_valid_date_or_suffix(date_str: str) -> str:
    """
    Checks if the given string is a valid date in YYYYMMDD format or a valid date with a suffix (YYYYMMDD-N).
    If valid, update the string as follows:
      - If the base date equals today's date:
           - If no suffix exists, append "-2".
           - If a suffix exists, increment the counter (e.g., -2 becomes -3).
      - If the base date is not today's date:
           - Replace the entire value with today's date (without any suffix).
    If the string is not a valid date (or date with suffix), return it unchanged.
    """
    pattern = re.compile(r"^(\d{8})(?:-(\d+))?$")
    match = pattern.match(date_str)
    if not match:
        return date_str

    base_date = match.group(1)
    suffix = match.group(2)

    try:
        datetime.strptime(base_date, "%Y%m%d")
    except ValueError:
        return date_str

    today_str = datetime.today().strftime("%Y%m%d")

    if base_date == today_str:
        if suffix is None:
            return f"{today_str}-2"
        else:
            try:
                counter = int(suffix)
            except ValueError:
                return date_str
            return f"{today_str}-{counter + 1}"
    else:
        return today_str

def update_dates_in_data(data: dict[str, list[dict[str, str]]]) -> dict[str, list[dict[str, str]]]:
    """
    Iterates over each key and nested dictionary in 'data' and updates any valid date or date-with-suffix
    field using update_if_valid_date_or_suffix. Returns the updated data structure.
    """
    updated_data = {}
    for outer_key, list_of_dicts in data.items():
        updated_list = []
        for inner_dict in list_of_dicts:
            updated_inner = {}
            for sub_key, value in inner_dict.items():
                updated_inner[sub_key] = update_if_valid_date_or_suffix(value)
            updated_list.append(updated_inner)
        updated_data[outer_key] = updated_list
    return updated_data


def find_yaml_block_indices(file_path: str, target_key: str) -> tuple[int, int]:
    """
    Finds the start and end indices of the block corresponding to the target key in a YAML file.

    The block is defined as the lines following the target key's definition (i.e. the line after 
    "target_key:") until the next top-level key is encountered. A new top-level key is detected if a 
    non-empty line (after stripping) starts at column 0 and does not start with a dash ('-').

    Args:
        file_path: Path to the YAML file.
        target_key: The top-level key whose block indices should be found.

    Returns:
        A tuple (start_index, end_index) where:
          - start_index is the index of the first line of the target key's block (i.e. immediately after the key line).
          - end_index is the index of the first line of the next top-level key, or len(lines) if none is found.

    Raises:
        ValueError: If the target key is not found in the file.
    """
    with open(file_path, 'r') as f:
        lines = f.readlines()

    # Locate the target key's definition.
    key_index = None
    for i, line in enumerate(lines):
        # A top-level key should start at the left margin and be followed by a colon.
        if line.lstrip() == line and line.startswith(target_key + ":"):
            key_index = i
            break

    if key_index is None:
        raise ValueError(f"Key '{target_key}' not found in file.")

    # The block is assumed to start immediately after the key definition.
    start_index = key_index + 1

    # Find the first line after the block that is a new top-level key.
    end_index = None
    for j in range(start_index, len(lines)):
        # Strip leading whitespace for checking.
        stripped = lines[j].lstrip()
        # If the line is non-empty, its first non-space character is not '-' (i.e. not a list item),
        # and the line starts at column 0, we assume it's a new top-level key.
        if lines[j].strip() and lines[j][0] != ' ' and not stripped.startswith('-'):
            end_index = j
            break
    if end_index is None:
        end_index = len(lines)

    return start_index, end_index


def list_item_to_yaml_str(list_item: list[dict[str, str]]) -> str:
    """
    Merges a list of one-key dictionaries into one mapping and returns a YAML-formatted string.
    For example, given:
      [{'timestampX': '20250329'}, {'timestampY': '20250329'}, {'anotherBlah': 'heyNowString'}, {'countyThing': '1'}, {'numberThing': '1000'}]
    this returns:
      - timestampX: "20250329"
        timestampY: "20250329"
        anotherBlah: "heyNowString"
        countyThing: "1"
        numberThing: "1000"
    """
    merged = {}
    for d in list_item:
        merged.update(d)
    
    lines = []
    first = True
    for key, value in merged.items():
        if first:
            lines.append(f"- {key}: \"{value}\"")
            first = False
        else:
            lines.append(f"  {key}: \"{value}\"")
    return "\n".join(lines)


def insert_input_str_lines(file_path: str, input_list: list[dict[str, str]], insertion_index: int) -> str:
    """
    Reads the file at file_path and inserts a YAML block—created from input_list—at insertion_index.
    
    The input_list is a list of dictionaries (each with one key/value) that will be merged into a single YAML list item.
    The resulting YAML block will have a trailing newline, and an extra line with a single space is appended.
    The new block is inserted without overwriting any existing lines.
    
    Args:
        file_path: Path to the input file.
        input_list: A list of dictionaries to be converted to a YAML-formatted block.
        insertion_index: The line number where the new block will be inserted.
                         (For example, if your block indices tuple is (16, 27), use 27.)
    
    Returns:
        A string containing the modified file content.
    """
    with open(file_path, 'r') as f:
        lines = f.readlines()
    
    # Convert the input list to a YAML-formatted string.
    yaml_str = list_item_to_yaml_str(input_list)
    
    # Ensure yaml_str ends with a newline.
    if not yaml_str.endswith("\n"):
        yaml_str += "\n"
    
    # Append an extra line with a single space.
    yaml_str += " \n"
    
    # Optionally: If the line at insertion_index is blank, remove it.
    if insertion_index < len(lines) and lines[insertion_index].strip() == "":
        del lines[insertion_index]
    
    # Insert the new YAML block at the specified index.
    # lines_up_to_yaml_string + yaml_string + rest_of_lines
    new_lines = lines[:insertion_index-1] + [yaml_str] + lines[insertion_index:]
    return "".join(new_lines)




def check_dates_in_data(data: dict[str, list[dict[str, str]]]) -> None:
    """
    Updates the dates in the data structure and prints the final updated data structure for each top-level key.
    """
    updated_data = update_dates_in_data(data)
    
    for outer_key, list_of_dicts in updated_data.items():
        print(f"Final structure for key '{outer_key}':")
        print(list_of_dicts)
        print()  # Extra newline for clarity


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="YAML update tool")
    parser.add_argument('subcommand', choices=['put'],
                        help="Subcommand: 'put' (currently the only supported action)")
    parser.add_argument('manifest_file',
                        help="Path to the target manifest YAML file (e.g. repo/manifest-01/manifest.yaml)")
    parser.add_argument('--replacements_dir',
                        help="Directory containing updates (not used in this minimal example)")
    args = parser.parse_args()

    if not args.manifest_file:
        print("Error: manifest_file must be provided")
        exit(1)

    if not args.replacements_dir:
        print("Error: --replacements_dir must be provided")
        exit(1)

    backup_file = create_backup(args.manifest_file)

    replacements_file = args.replacements_dir + '/listincrement.yaml'
    keys = get_toplevel_keys(replacements_file)
    counts = get_last_list_index_for_key(args.manifest_file, keys)
    
    print("Last index for list under key:", counts)
    keyvalues = get_list_item_key_values(args.manifest_file, counts)

    # check_dates_in_data(keyvalues)

    updated_data = update_dates_in_data(keyvalues)

    print(f"updated_data: {updated_data}")

    start_index, end_index = find_yaml_block_indices(args.manifest_file, 'whateverThing')
    print(start_index, end_index)

    print(insert_input_str_lines(args.manifest_file, updated_data['whateverThing'], end_index))
