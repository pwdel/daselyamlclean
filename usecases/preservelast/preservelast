#!/usr/bin/env python3

import subprocess
import argparse
import shutil
import os
import re
from typing import Dict, List
from datetime import datetime

def create_backup(manifest_file):
    """
    Creates a backup of the manifest file by appending '.backup' to its name.
    If a backup already exists, it is removed first.
    Returns the backup file path.
    """
    backup_file = manifest_file + ".backup"
    if os.path.exists(backup_file):
        os.remove(backup_file)
        print(f"Deleted existing backup file: {backup_file}")
    shutil.copy2(manifest_file, backup_file)
    print(f"Created backup file: {backup_file}")
    return backup_file

def dasel_read(manifest_file, selector=""):
    """
    Helper function to run a dasel get command and return the output.
    If selector is empty, the "--selector" flag is omitted.
    """
    cmd = [
        "dasel",
        "--file", manifest_file,
        "--read", "yaml"
    ]
    if selector:
        cmd.extend(["--selector", selector])
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()

def get_toplevel_keys(file_path):
    """
    Uses dasel_read on the provided file (with an empty selector)
    to extract the top-level keys from the YAML.
    For example, if the file contains:
      firstThing: null
      whateverThing: null
    then this function returns ["firstThing", "whateverThing"].
    """
    output = dasel_read(file_path, "")
    # Use regex to capture keys at the start of a line
    keys = re.findall(r'^(\S+):', output, re.MULTILINE)
    return keys

def dasel_last_index_for_key(manifest_file, key):
    """
    Helper function to run a dasel get command that uses the count() function on the given key.
    For example, if key is "whateverThing", this function will run:
    
      dasel --file <manifest_file> --read yaml --selector 'whateverThing.all().count()' --type yaml
      
    and return the output.
    """
    selector = f"{key}.all().count()"
    cmd = [
        "dasel",
        "--file", manifest_file,
        "--read", "yaml",
        "--selector", selector,
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()

def get_last_list_index_for_key(manifest_file, keys):
    """
    For each key in the provided list, provide a dict showing the last index
    in the list under a given key.
    """
    counts = {}
    for key in keys:
        try:
            count_output = dasel_last_index_for_key(manifest_file, key)
            counts[key] = int(count_output) - 1
        except Exception as e:
            print(f"Error retrieving count for key '{key}': {e}")
            counts[key] = None
    return counts

def get_last_item_elements(manifest_file, key, last_index):
    """
    For a given key in the manifest file, constructs a selector for the last element in the list,
    reads its YAML with dasel_read, and returns the keys (if the element is a dictionary).
    
    For example, if key is "whateverThing" and last_index is 1,
    it runs:
      dasel --file <manifest_file> --read yaml --selector 'whateverThing.[1]' --type yaml
    and returns the list of keys in that mapping.
    """
    selector = f"{key}.[{last_index}]"
    output = dasel_read(manifest_file, selector)
    try:
        data = yaml.safe_load(output)
    except Exception as e:
        print(f"Error loading YAML for selector '{selector}': {e}")
        return []
    
    if isinstance(data, dict):
        return list(data.keys())
    else:
        print(f"Data for selector '{selector}' is not a mapping. Found type: {type(data)}")
        return []

def get_list_item_key_values(manifest_file: str, counts_dict: Dict[str, int]) -> Dict[str, List[Dict[str, str]]]:
    """
    For each key in counts_dict (which maps top-level keys to their last index),
    constructs a selector to get the last list item, uses dasel_read to retrieve
    its output (as a multi-line string), then splits that output into lines and
    parses each line into a dict with one keyâ€“value pair.
    
    Returns a dictionary mapping each key to a list of dictionaries (one per line).
    """
    result: Dict[str, List[Dict[str, str]]] = {}
    for key, last_index in counts_dict.items():
        selector: str = f"{key}.[{last_index}]"
        output: str = dasel_read(manifest_file, selector)
        line_dicts: List[Dict[str, str]] = []
        for line in output.splitlines():
            if line.strip():  # skip blank lines
                if ":" in line:
                    parts = line.split(":", 1)
                    k = parts[0].strip()
                    v = parts[1].strip()
                    # Remove surrounding quotes if present
                    if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
                        v = v[1:-1]
                    line_dicts.append({k: v})
        result[key] = line_dicts
    return result

def update_if_valid_date_or_suffix(date_str: str) -> str:
    """
    Checks if the given string is a valid date in YYYYMMDD format or a valid date with a suffix (YYYYMMDD-N).
    If valid, update the string as follows:
      - If the base date equals today's date:
           - If no suffix exists, append "-2".
           - If a suffix exists, increment the counter (e.g., -2 becomes -3).
      - If the base date is not today's date:
           - Replace the entire value with today's date (without any suffix).
    If the string is not a valid date (or date with suffix), return it unchanged.
    """
    pattern = re.compile(r"^(\d{8})(?:-(\d+))?$")
    match = pattern.match(date_str)
    if not match:
        return date_str

    base_date = match.group(1)
    suffix = match.group(2)

    try:
        datetime.strptime(base_date, "%Y%m%d")
    except ValueError:
        return date_str

    today_str = datetime.today().strftime("%Y%m%d")

    if base_date == today_str:
        if suffix is None:
            return f"{today_str}-2"
        else:
            try:
                counter = int(suffix)
            except ValueError:
                return date_str
            return f"{today_str}-{counter + 1}"
    else:
        return today_str

def update_dates_in_data(data: dict[str, list[dict[str, str]]]) -> dict[str, list[dict[str, str]]]:
    """
    Iterates over each key and nested dictionary in 'data' and updates any valid date or date-with-suffix
    field using update_if_valid_date_or_suffix. Returns the updated data structure.
    """
    updated_data = {}
    for outer_key, list_of_dicts in data.items():
        updated_list = []
        for inner_dict in list_of_dicts:
            updated_inner = {}
            for sub_key, value in inner_dict.items():
                updated_inner[sub_key] = update_if_valid_date_or_suffix(value)
            updated_list.append(updated_inner)
        updated_data[outer_key] = updated_list
    return updated_data


#### INSERTION SECTION ####

def list_item_to_yaml_str(list_item: list[dict[str, str]]) -> str:
    """
    Merges a list of one-key dictionaries into one mapping and returns a YAML-formatted string.
    For example, given:
      [{'timestampX': '20250329'}, {'timestampY': '20250329'}, {'anotherBlah': 'heyNowString'}, {'countyThing': '1'}, {'numberThing': '1000'}]
    this returns:
      - timestampX: "20250329"
        timestampY: "20250329"
        anotherBlah: "heyNowString"
        countyThing: "1"
        numberThing: "1000"
    """
    merged = {}
    for d in list_item:
        merged.update(d)
    
    lines = []
    first = True
    for key, value in merged.items():
        if first:
            lines.append(f"- {key}: \"{value}\"")
            first = False
        else:
            lines.append(f"  {key}: \"{value}\"")
    return "\n".join(lines)

def find_yaml_block_indices(file_path: str, target_key: str) -> tuple[int, int, list[str]]:
    """
    Reads the file once and finds the start and end indices of the block corresponding to the target key.
    
    The block is defined as the lines following the target key's definition (i.e. the line after
    "target_key:") until the next top-level key is encountered (a non-empty line at column 0 that does
    not start with a dash ('-')) or end-of-file.
    
    Returns:
        A tuple (start_index, end_index, lines) where:
          - start_index: index of the first line of the target key's block.
          - end_index: index of the first line of the next top-level key (or len(lines) if none is found).
          - lines: a snapshot of the file as a list of strings.
          
    Raises:
        ValueError: If the target key is not found.
    """
    with open(file_path, 'r') as f:
        lines = f.readlines()

    # Locate the target key's definition.
    key_index = None
    for i, line in enumerate(lines):
        if line.lstrip() == line and line.startswith(target_key + ":"):
            key_index = i
            break

    if key_index is None:
        raise ValueError(f"Key '{target_key}' not found in file.")

    # The block starts immediately after the key definition.
    start_index = key_index + 1

    # Find the first line after the block that is a new top-level key.
    end_index = None
    for j in range(start_index, len(lines)):
        stripped = lines[j].lstrip()
        if lines[j].strip() and lines[j][0] != ' ' and not stripped.startswith('-'):
            end_index = j
            break
    if end_index is None:
        end_index = len(lines)

    return start_index, end_index, lines


def insert_input_str_lines(lines_snapshot: list[str], input_list: list[dict[str, str]], insertion_index: int) -> str:
    """
    Inserts a YAML block into the provided snapshot of file lines at the given insertion index.
    
    The input_list is a list of dictionaries that will be merged into a single YAML-formatted block.
    The block is converted to a string (using list_item_to_yaml_str), ensured to end with a newline,
    and then appended with an extra line containing a single space.
    
    The new block is inserted into the snapshot without overwriting any existing lines.
    
    Args:
        lines_snapshot: List of strings representing the file content.
        input_list: List of dictionaries to be converted into a YAML block.
        insertion_index: The index (line number) where the block will be inserted.
    
    Returns:
        A string representing the modified file content.
    """
    # Convert the input list into a YAML-formatted string.
    yaml_str = list_item_to_yaml_str(input_list)
    
    # Ensure the YAML string ends with a newline.
    if not yaml_str.endswith("\n"):
        yaml_str += "\n"
    
    # Append an extra line with a single space.
    yaml_str += " \n"
    
    # Optionally remove a blank line at the insertion index.
    if insertion_index < len(lines_snapshot) and lines_snapshot[insertion_index].strip() == "":
        del lines_snapshot[insertion_index]
    
    # Insert the YAML block.
    new_lines = lines_snapshot[:insertion_index-1] + [yaml_str] + lines_snapshot[insertion_index:]
    return "".join(new_lines)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="YAML update tool")
    parser.add_argument('subcommand', choices=['put'],
                        help="Subcommand: 'put' (currently the only supported action)")
    parser.add_argument('manifest_file',
                        help="Path to the target manifest YAML file (e.g. repo/manifest-01/manifest.yaml)")
    parser.add_argument('--replacements_dir',
                        help="Directory containing updates (not used in this minimal example)")
    args = parser.parse_args()

    if not args.manifest_file:
        print("Error: manifest_file must be provided")
        exit(1)

    if not args.replacements_dir:
        print("Error: --replacements_dir must be provided")
        exit(1)

    backup_file = create_backup(args.manifest_file)

    replacements_file = args.replacements_dir + '/listincrement.yaml'
    keys = get_toplevel_keys(replacements_file)
    counts = get_last_list_index_for_key(args.manifest_file, keys)
    
    print("Last index for list under key:", counts)
    keyvalues = get_list_item_key_values(args.manifest_file, counts)

    updated_data = update_dates_in_data(keyvalues)

    print(f"updated_data: {updated_data}")

    start_index, end_index, lines_snapshot = find_yaml_block_indices(args.manifest_file, 'whateverThing')
    print(start_index, end_index, lines_snapshot)

    print(insert_input_str_lines(lines_snapshot, updated_data['whateverThing'], end_index))
